#include <types.h>
#include <zlib.h>
#include <string.h>
#include <page.h>
#include <appleboot-mem_pieces.h>
#include <appleboot-boot.h>
#include <appleboot-ctype.c>
#include <appleboot-nbpmac_id.h>
#include <libfdt.h>
#include <gunzip_util.h>

/* from asm/mmu.h */
#ifndef BL_8M
#define BL_8M 0x03f
#endif
#ifndef BL_16M
#define BL_16M 0x7f
#endif
#ifndef BL_256M
#define BL_256M 0x7ff
#endif
#ifndef BPP_RW
#define BPP_RW 0x02
#endif
#ifndef PP_RWXX
#define PP_RWXX 0
#endif

/* from asm/pgtable.h */
#ifndef _PAGE_GUARDED
#define _PAGE_GUARDED	0x008
#endif
#ifndef _PAGE_COHERENT
#define _PAGE_COHERENT	0x010
#endif
#ifndef _PAGE_NO_CACHE
#define _PAGE_NO_CACHE	0x020
#endif

static struct gunzip_state gzstate;

extern unsigned long *start_dt_PM;
extern unsigned long *end_dt_PM;
extern unsigned long *start_dt_PFM;
extern unsigned long *end_dt_PFM;
extern unsigned long *start_dt_PB;
extern unsigned long *end_dt_PB;
extern unsigned long *kernel_img_start;
extern unsigned long *kernel_img_end;
extern unsigned long *end;

static unsigned long start_dtb;
static unsigned long end_dtb;

/* from asm/io.h */
inline void eieio(void)
{
	__asm__ __volatile__ ("eieio" : : : "memory");
}

#ifdef LOADER_PRINT

static void print_mem_info(void);

static void clearscreen(void);
static void flushscreen(void);
static void drawchar(char c);

void drawstring(const char *c);
void drawhex(unsigned long v);

static void draw_byte(unsigned char c, long locX, long locY);
static void draw_byte_32(unsigned char *bits, unsigned long *base);
static void draw_byte_16(unsigned char *bits, unsigned long *base);
static void draw_byte_8(unsigned char *bits, unsigned long *base);
static void draw_byte_4(unsigned char *bits, unsigned long *base);
static void draw_byte_2(unsigned char *bits, unsigned short *base);
static void draw_byte_1(unsigned char *bits, unsigned char *base);

#define cmapsz	(16*256)
#define bprint drawstring
#define puts drawstring

static unsigned char vga_font[cmapsz];

static long g_loc_X;
static long g_loc_Y;
static long g_max_loc_X;
static long g_max_loc_Y;

static void init_ariel2_cmap(void);
static void init_true_cmap(unsigned long, int, int);
static void init_direct_cmap(unsigned long, int, int);

#else /* LOADER_PRINT */

#define puts(str)	do { } while(0)
#define drawhex(val)	do { } while(0)
#define bprint(str)	do { } while(0)
#define flushscreen()	do { } while(0)

#undef BOOTX_MEM_CHECK

#endif /* LOADER_PRINT */

static void setup_mem(struct mem_pieces *);
static void gunzip(void *, int, unsigned char *, int *);
static char *strstr(const char *, const char *);
static unsigned long strtoul(const char *, char **, unsigned int);
//static char * strncpy(char * dest,const char *src,size_t count);
static void prepare_bats(struct mem_pieces *);

#define exit() { while(1); }
#define MAX_KERNEL_SIZE 0x400000

static struct boot_infos *boot_infos = 0;
static struct boot_args *mach_infos = 0;

/* length of wait loop for debugging info (0 - 255) */
static int booter_debug_wait = 0;

struct mem_pieces phys_mem = { 0, {{0,},}};

unsigned long kernel_src = 0;
unsigned long kernel_size = 0;
unsigned long kernel_stack = 0;
unsigned long boot_infos_loc = 0;

unsigned long ramdisk_base = 0;
unsigned long ramdisk_size = 0;

unsigned long code_reloc = 0;
unsigned long code_size = 0;
unsigned long code_restart = 0;

unsigned long disp_IBAT[2] = {0, 0};
unsigned long disp_DBAT[2] = {0, 0};
unsigned long kern_BAT0[2] = {0, 0};
unsigned long kern_BAT1[2] = {0, 0};
unsigned long io_BAT[2] = {0, 0};

static unsigned long io_addr;

unsigned long _SDR1;

extern unsigned char end_of_code[];
extern unsigned char _restart[];
extern unsigned char scratch[];


#ifdef BOOTX_MEM_CHECK
struct reg_property mem_bank[10] = {
	{0,0},
	/* According to Apple docs, we may find RAM at the following 8 */
	/* addresses. */
	{0x01000000,0}, {0x05000000,0}, {0x09000000,0}, {0x0d000000,0},
	{0x11000000,0}, {0x15000000,0}, {0x19000000,0}, {0x1d000000,0},
	/* It appears that for a 64MB SIMM, the following offset is used. */
	/* There may be more like this. */
	{0x10000000,0}
};
#endif

#ifndef BOOTX_MEM_CHECK
static void
bootx_init(struct boot_infos *orig_bi)
{
 	char *p, *cmdline;

	if (orig_bi->ram_disk_size) {
		orig_bi->total_params_size -= orig_bi->ram_disk_size;
		ramdisk_base = (unsigned long)orig_bi + orig_bi->ram_disk;
		ramdisk_size = orig_bi->ram_disk_size;
	}

	memcpy((void *)boot_infos, (void *)orig_bi, orig_bi->total_params_size);

	cmdline = (char *)boot_infos + boot_infos->kernel_params_offset;
	if ((p = strstr(cmdline, "booter_debug_wait=")))
		booter_debug_wait = strtoul(p + 18, 0, 0);
}
#endif /* !BOOTX_MEM_CHECK */

static void
appleboot_init(struct boot_args *args)
{
	int len, i;
	char *p;

	mach_infos = args;
//	boot_infos->version = 5;
	boot_infos->version = APPLE_BOOTER_SIGS;
	boot_infos->compatible_version = 5; /* perhaps, 1 is appropriate? */
	boot_infos->machine_id = mach_infos->machine_type;

	switch(boot_infos->machine_id) {
	/* PDM class NuBus Power Macintoshes */
	case MACHID_POWERMAC8100_120:
	case MACHID_POWERMAC7100_66ALT:
	case MACHID_AWS9150_80:
	case MACHID_POWERMAC8100_110:
	case MACHID_POWERMAC7100_80:
	case MACHID_POWERMAC8100_100:
	case MACHID_AWS9150_120:
	case MACHID_PDM100F:
	case MACHID_POWERMAC8100_80:
	case MACHID_PDM66F:
	case MACHID_POWERMAC6100_60:
	case MACHID_POWERMAC6100_66:
	case MACHID_POWERMAC6100_80:
	case MACHID_PDM80WLCD:
	case MACHID_POWERMAC7100_66:
	case MACHID_POWERMAC7100_80CHIPPED:
	default:
		boot_infos->architecture = BOOT_ARCH_NUBUS | BOOT_ARCH_NUBUS_PDM;
		break;
	/* PPC-equipped Performas */
	case MACHID_POWERMAC5200:
	case MACHID_POWERMAC6200:
		boot_infos->architecture = BOOT_ARCH_NUBUS | BOOT_ARCH_NUBUS_PERFORMA;
		break;
	/* PPC-capable NuBus PowerBooks */
	case MACHID_POWERBOOK520:
	case MACHID_POWERBOOKDUO2300:
	case MACHID_POWERBOOK500PPC:
	case MACHID_POWERBOOK5300:
	case MACHID_POWERBOOK1400:
		boot_infos->architecture = BOOT_ARCH_NUBUS | BOOT_ARCH_NUBUS_POWERBOOK;
		break;
	}
	boot_infos->device_tree_offset = 0;
	boot_infos->device_tree_size = 0;
	boot_infos->dispDeviceRect[0] = 0;
	boot_infos->dispDeviceRect[1] = 0;
	boot_infos->dispDeviceRect[2] = mach_infos->video.v_width;
	boot_infos->dispDeviceRect[3] = mach_infos->video.v_height;
	boot_infos->dispDeviceDepth = mach_infos->video.v_depth;
	boot_infos->dispDeviceBase = (unsigned char *) mach_infos->video.v_base;
	boot_infos->dispDeviceRowBytes = mach_infos->video.v_rowbytes;
	boot_infos->dispDeviceColorsOffset = 0;
	boot_infos->dispDeviceRegEntryOffset = 0;
	boot_infos->logicalDisplayBase = boot_infos->dispDeviceBase;
	boot_infos->ram_disk = 0;
	boot_infos->ram_disk_size = 0;
	boot_infos->kernel_params_offset = sizeof (struct boot_infos);
	/* fix up MkLinux-style rootdev= command line option to Linux style */
	if ((p = strstr(mach_infos->command_line, "rootdev=")))
		strncpy(p, "   root=", 8);
	if ((p = strstr(mach_infos->command_line, "booter_debug_wait=")))
		booter_debug_wait = strtoul(p + 18, 0, 0);
	len = strlen(mach_infos->command_line);
	if (len >= BOOT_LINE_LENGTH)
		len = BOOT_LINE_LENGTH - 1;
	strncpy((char *) (scratch + sizeof(struct boot_infos)),
	       mach_infos->command_line, len);
	((char *)scratch)[sizeof(struct boot_infos) + len] = '\0';
	for (i = 0; i < MAX_DRAM_BANKS; i++) {
		boot_infos->mem_map[i].base = mach_infos->physical_dram[i].base;
		boot_infos->mem_map[i].size = mach_infos->physical_dram[i].size;
	}
	boot_infos->mem_map_size = MAX_DRAM_BANKS; /* not used currently */
	boot_infos->frame_buffer_size = 0;
	boot_infos->total_params_size = sizeof(struct boot_infos) + len + 1;

	/* access "mach_infos" for the last time */
	ramdisk_base = mach_infos->task_info.base_addr + 32;
	ramdisk_size = *(unsigned long *) mach_infos->task_info.base_addr;
}

#ifdef BOOTX_MEM_CHECK
void
init_args (unsigned long r3, unsigned long r4)
{
	boot_infos = (struct boot_infos *) scratch;
	appleboot_init((struct boot_args *)r4);

	clearscreen();

	g_loc_X = 0;
	g_loc_Y = 0;
	g_max_loc_X = boot_infos->dispDeviceRect[2] / 8;
	g_max_loc_Y = boot_infos->dispDeviceRect[3] / 16;

	/* do minimal setup for semi-correct cmap */
	switch ((unsigned long)boot_infos->dispDeviceBase & 0xfff00000UL) {
	case 0x100000UL:
		init_ariel2_cmap();
		break;
	case 0xe0100000UL:
		init_true_cmap(0xe0f30000UL, 16, 1);
		break;
	case 0x60000000UL:
		init_true_cmap(0x50f20040UL, 2, 0);
		break;
	default:
		if (boot_infos->architecture & BOOT_ARCH_NUBUS_PERFORMA)
			init_direct_cmap(0x50f24000, 8, 0);
		break;
	}

	print_mem_info();

	flushscreen();
	while(1);
}

static void print_mem_info(void)
{
	int i;
	static char num_table[] = "0123456789";
	unsigned long size, digits, need_zero, found;

	bprint("Memory Command Reporter 0.0.4\n\n");

	found = 0;
	for (i = 0; i < MAX_DRAM_BANKS; i++) {
		int j, flag;
		if (boot_infos->mem_map[i].size == 0)
			continue;
		flag = 0;
		for (j = 0; j < 10; j++) {
			if (boot_infos->mem_map[i].base == mem_bank[j].address){
				mem_bank[j].size = boot_infos->mem_map[i].size;
				found = 1;
				flag = 1;
			}
		}
		if (flag == 0) {
			bprint("Unsupported base address 0x");
			drawhex(boot_infos->mem_map[i].base);
			bprint("\n\n");
			bprint("Please report this number to developers.\n");
		}
	}

	if (!found) {
		bprint("No memory found at any known base address....\n");
		return;
	}

	bprint("If your booter has trouble recognizing all of your SIMMs,");
	bprint(" the following kernel argument might help:\n");
	bprint("\n\tnubus_simm=");

	for (i = 0; i < 10; i++) {
		size = mem_bank[i].size >> 20;
		if (!size)
			continue;
		if (i > 0)
			drawchar(',');
		drawchar('b');
		drawchar(num_table[i]);
		drawchar(':');
		need_zero = 0;
		if ((digits = size / 100)) {
			drawchar(num_table[digits]);
			size -= digits * 100;
			need_zero = 1;
		}
		if ((digits = size / 10)) {
			drawchar(num_table[digits]);
			size -= digits * 10;
		} else if (need_zero)
			drawchar(num_table[0]);
		drawchar(num_table[size]);
		drawchar('m');
	}

	bprint("\nThis machine has a MachID of: 0x");
	drawhex(boot_infos->machine_id);
	bprint("\n");
}

void
setup_misc (void)
{
}

#else /* BOOTX_MEM_CHECK */
void
init_args (unsigned long r3, unsigned long r4)
{
	boot_infos = (struct boot_infos *) scratch;

	if (r3 == BOOTX_SIGS)
		/* we are from BootX */
		bootx_init((struct boot_infos *)r4);
	else
		/* we are from Apple MkLinux Booter */
		appleboot_init((struct boot_args *)r4);

	switch(boot_infos->machine_id) {
	/* PDM class NuBus Power Macintoshes */
	case MACHID_POWERMAC8100_120:
	case MACHID_POWERMAC7100_66ALT:
	case MACHID_AWS9150_80:
	case MACHID_POWERMAC8100_110:
	case MACHID_POWERMAC7100_80:
	case MACHID_POWERMAC8100_100:
	case MACHID_AWS9150_120:
	case MACHID_PDM100F:
	case MACHID_POWERMAC8100_80:
	case MACHID_PDM66F:
	case MACHID_POWERMAC6100_60:
	case MACHID_POWERMAC6100_66:
	case MACHID_POWERMAC6100_80:
	case MACHID_PDM80WLCD:
	case MACHID_POWERMAC7100_66:
	case MACHID_POWERMAC7100_80CHIPPED:
	default:
		start_dtb = (unsigned long)&start_dt_PM;
		end_dtb = (unsigned long)&end_dt_PM;
		break;
	/* PPC-equipped Performas */
	case MACHID_POWERMAC5200:
	case MACHID_POWERMAC6200:
		start_dtb = (unsigned long)&start_dt_PFM;
		end_dtb = (unsigned long)&end_dt_PFM;
		break;
	/* PPC-capable NuBus PowerBooks */
	case MACHID_POWERBOOK520:
	case MACHID_POWERBOOKDUO2300:
	case MACHID_POWERBOOK500PPC:
	case MACHID_POWERBOOK5300:
	case MACHID_POWERBOOK1400:
		start_dtb = (unsigned long)&start_dt_PB;
		end_dtb = (unsigned long)&end_dt_PB;
		break;
	}

	switch ((unsigned long)boot_infos->dispDeviceBase & 0xfff00000UL) {
	case 0xe0100000UL: /* Apple A/V card */
		io_addr = 0xe0800000UL;
		break;
	default:
		io_addr = 0x50800000UL;
		break;
	}

	setup_mem(&phys_mem);
}


#ifdef LOADER_PRINT
static void print_mem_info(void)
{
	bprint("\nMemory configuration:\n");
	{
		int i;
		for (i = 0; i < MAX_DRAM_BANKS; i++) {
			if (boot_infos->mem_map[i].size == 0)
				continue;
			bprint("0x");
			drawhex(boot_infos->mem_map[i].base);
			bprint(" - 0x");
			drawhex(boot_infos->mem_map[i].base
				+ boot_infos->mem_map[i].size - 1);
			bprint("\n");
		}
		bprint("\n");
	}
}
#endif /* LOADER_PRINT */


static void
prepare_bats(struct mem_pieces *mp)
{
	unsigned long pvr, kaddr, vaddr;

	vaddr = (unsigned long) boot_infos->dispDeviceBase;
	__asm__ __volatile__ ("mfspr %0, 287" : "=r" (pvr));
	if ((pvr >> 16) != 1) {
		/* 603, 604, G3, G4, ... */
		kern_BAT0[0] = (BL_256M<<2) | 2;
		kern_BAT0[1] = BPP_RW;
		io_BAT[0] = io_addr | (BL_8M<<2) | 2;
		io_BAT[1] = io_addr | (_PAGE_NO_CACHE | _PAGE_GUARDED | BPP_RW);
		vaddr &= 0xFF000000UL;
		if (vaddr) {
			disp_DBAT[0] = vaddr | (BL_16M<<2) | 2;
			disp_DBAT[1] = vaddr | (_PAGE_NO_CACHE | _PAGE_GUARDED
					| BPP_RW);
		}
	} else {
		/* 601 and BOOT_ARCH_NUBUS_PDM */
		kern_BAT0[0] = 0;
		kern_BAT0[1] = BL_8M | 0x40;
		if (mp->n_regions > 1) {
			kaddr = mp->regions[1].address & 0xFFF00000UL;
			kern_BAT1[0] = kaddr;
			kern_BAT1[1] = kaddr | BL_8M | 0x40;
		}
		io_BAT[0] = io_addr | (_PAGE_NO_CACHE | PP_RWXX);
		io_BAT[1] = io_addr | BL_8M | 0x40;
		vaddr &= 0xFF800000UL;
		if (vaddr) {
			disp_IBAT[0] = vaddr | (_PAGE_NO_CACHE | PP_RWXX);
			disp_IBAT[1] = vaddr | BL_8M | 0x40;
		}
	}
}


static void
setup_mem (struct mem_pieces *mp)
{
	int i, imax;
	unsigned long max;
//	unsigned long dummy_hash, hash_mask;

	mp->n_regions = 0;
	for (i = 0; i < MAX_DRAM_BANKS; i++) {
		if (boot_infos->mem_map[i].size == 0)
			continue;
		mp->regions[mp->n_regions].address
						= boot_infos->mem_map[i].base;
		mp->regions[mp->n_regions].size = boot_infos->mem_map[i].size;
		mp->n_regions++;
	}

	mem_pieces_sort(mp);
	mem_pieces_coalesce(mp);

	/* Use the largest region (and 0th) only */
	max = 0;
	imax = 0;
	for (i = 1; i < mp->n_regions; i++) {
		if (mp->regions[i].size > max) {
			max = mp->regions[i].size;
			imax = i;
		}
	}

	if (max) {
		mp->n_regions = 2;
		if (imax != 1) {
			mp->regions[1].size = mp->regions[imax].size;
			mp->regions[1].address = mp->regions[imax].address;
		}
	}

	prepare_bats(mp);

	if (boot_infos->architecture & BOOT_ARCH_NUBUS_PDM)
		mem_pieces_remove(mp, PDM_VIDEO_RAM, PDM_VIDEO_SIZE, 1);

	/* make phys 0x0 unavailable, otherwise gunzip() freaks out.... */
	mem_pieces_remove(mp, 0, TEXT_BASE, 1);
}

/*
 * populate the /memory node with
 * ramdisk parameters and command line
 */
void setup_devtree_memory(void *fdt)
{
	int retval, nodeoffset, i, num_mem_banks = 0;

	retval = fdt_path_offset(fdt, "/memory");
	if(retval < 0) {
		bprint("fdt_path_offset failed (");
		drawhex(retval);
		bprint(")\n");
		bprint("setup_devtree_memory: no /memory node found!\n");
		return;
	}
	nodeoffset = retval;

	/*
	 * I assume there aren't any empty (size == 0) mem_map entries
	 * followed by non-empty ones later on
	 */
	for (i = 0; i < boot_infos->mem_map_size; i++) {
		if (boot_infos->mem_map[i].size == 0)
			continue;
		num_mem_banks++;
	}
	if(!num_mem_banks) {
		bprint("setup_devtree_memory: didn't find any memory banks in boot_infos!\n");
		exit();
	}

	retval = fdt_setprop(fdt, nodeoffset, "reg", &boot_infos->mem_map[0],
				num_mem_banks * sizeof(boot_infos->mem_map[0]));
	if(retval < 0) {
		bprint("fdt_setprop failed (");
		drawhex(retval);
		bprint(")\n");
	}
}
/*
 * adapt the generic device tree
 * to suite the specific machine
 */
void setup_devtree_machdep(void *fdt)
{
	int retval, nodeoffset, len;
	unsigned long *retp;
	unsigned long storeval;

	switch (boot_infos->machine_id) {
	/* PDM class NuBus Power Macintoshes */
	case MACHID_POWERMAC8100_120:
	case MACHID_POWERMAC7100_66ALT:
	case MACHID_AWS9150_80:
	case MACHID_POWERMAC8100_110:
	case MACHID_POWERMAC7100_80:
	case MACHID_POWERMAC8100_100:
	case MACHID_AWS9150_120:
	case MACHID_PDM100F:
	case MACHID_POWERMAC8100_80:
	case MACHID_PDM66F:
	case MACHID_POWERMAC6100_60:
	case MACHID_POWERMAC6100_66:
	case MACHID_POWERMAC6100_80:
	case MACHID_PDM80WLCD:
	case MACHID_POWERMAC7100_66:
	case MACHID_POWERMAC7100_80CHIPPED:
	default:
		break;

	/* PPC-equipped Performas */
	case MACHID_POWERMAC5200:
	case MACHID_POWERMAC6200:
		break;

	/* PPC-capable NuBus PowerBooks */
	case MACHID_POWERBOOK520:
	case MACHID_POWERBOOK500PPC:
		/*
		 * these ones have quite some more devices on the I/O bus
		 * that 2300/5300/1400 don't have
		 * device tree would have to be extended to support them
		 * no support yet!
		 */
#if 0
		/* 500PPC doesn't have a media-bay */
		/* get media-bay node */
		retval = fdt_path_offset(fdt, "/whitney/media-bay");
		if(retval < 0) {
			bprint("fdt_path_offset failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: no /whitney/media-bay node found!\n");
			return;
		}
		nodeoffset = retval;

		/* delete media-bay node */
		retval = fdt_del_node(fdt, nodeoffset);
		if(retval < 0) {
			bprint("fdt_del_node failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: couldn't delete node /whitney/media-bay!\n");
			return;
		}
#endif

		/* 500PPC doesn't have a trex */
		/* get trex node */
		retval = fdt_path_offset(fdt, "/whitney/trex");
		if(retval < 0) {
			bprint("fdt_path_offset failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: no /whitney/trex node found!\n");
			return;
		}
		nodeoffset = retval;

		/* delete trex node */
		retval = fdt_del_node(fdt, nodeoffset);
		if(retval < 0) {
			bprint("fdt_del_node failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: couldn't delete node /whitney/trex!\n");
			return;
		}

		/* 500PPC doesn't have a baboon */
		/* get baboon node */
		retval = fdt_path_offset(fdt, "/whitney/baboon");
		if(retval < 0) {
			bprint("fdt_path_offset failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: no /whitney/baboon node found!\n");
			return;
		}
		nodeoffset = retval;

		/* delete baboon node */
		retval = fdt_del_node(fdt, nodeoffset);
		if(retval < 0) {
			bprint("fdt_del_node failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: couldn't delete node /whitney/baboon!\n");
			return;
		}

		/* 500PPC doesn't have a second serial port */
		/* get ch-b node */
		retval = fdt_path_offset(fdt, "/whitney/escc/ch-b");
		if(retval < 0) {
			bprint("fdt_path_offset failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: no /whitney/escc/ch-b node found!\n");
			return;
		}
		nodeoffset = retval;

		/* delete ch-b node */
		retval = fdt_del_node(fdt, nodeoffset);
		if(retval < 0) {
			bprint("fdt_del_node failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: couldn't delete node /whitney/escc/ch-b!\n");
			return;
		}

		break;

	case MACHID_POWERBOOKDUO2300:
		/* interrupt line of baboon is connected to where trex is connected on 1400/5300 */
		/* find trex node */
		retval = fdt_path_offset(fdt, "/whitney/trex");
		if(retval < 0) {
			bprint("fdt_path_offset failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: no /whitney/trex node found!\n");
			return;
		}
		nodeoffset = retval;

		retp = (unsigned long *)fdt_getprop(fdt, nodeoffset, "AAPL,interrupts", &len);
		if(retp == NULL) {
			bprint("fdt_getprop failed (");
			drawhex(len);
			bprint(")\n");
			bprint("setup_devtree_machdep: no property AAPL,interrupts of node /whitney/trex found!\n");
			return;
		}
		/* save interrupt value */
		storeval = *retp;

		/* delete trex node */
		retval = fdt_del_node(fdt, nodeoffset);
		if(retval < 0) {
			bprint("fdt_del_node failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: couldn't delete node /whitney/trex!\n");
			return;
		}
		
		/* get node of interrupt controller */
		retval = fdt_path_offset(fdt, "/whitney/m2");
		if(retval < 0) {
			bprint("fdt_path_offset failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: no /whitney/m2 node found!\n");
			return;
		}
		nodeoffset = retval;

		/* get pointer to interrupt property */
		retp = (unsigned long *)fdt_getprop(fdt, nodeoffset, "AAPL,interrupts", &len);
		if(retp == NULL) {
			bprint("fdt_getprop failed (");
			drawhex(len);
			bprint(")\n");
			bprint("setup_devtree_machdep: no property AAPL,interrupts of node /whitney/m2 found!\n");
			return;
		}
		if(len >= 5)
			/* change interrupt property for baboon (5th) */
			retp[4] = storeval;
		else {
			bprint("setup_devtree_machdep: property AAPL,interrupts of node /whitney/m2 has length of ");
			drawhex(len);
			bprint(", but at least 5 expected!\n");
			return;
		}

		/* get node of baboon */
		retval = fdt_path_offset(fdt, "/whitney/baboon");
		if(retval < 0) {
			bprint("fdt_path_offset failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: no /whitney/baboon node found!\n");
			return;
		}
		nodeoffset = retval;

		/* get pointer to interrupt property */
		retp = (unsigned long *)fdt_getprop(fdt, nodeoffset, "AAPL,interrupts", &len);
		if(retp == NULL) {
			bprint("fdt_getprop failed (");
			drawhex(len);
			bprint(")\n");
			bprint("setup_devtree_machdep: no property AAPL,interrupts of node /whitney/baboon found!\n");
			return;
		}
		if(len >= 1)
			/* change interrupt property for baboon itself */
			retp[0] = storeval;
		else {
			bprint("setup_devtree_machdep: property AAPL,interrupts of node /whitney/baboon has length of ");
			drawhex(len);
			bprint(", but at least 1 expected!\n");
			return;
		}

		/* 2300 has a modem where 1400/5300 have infrared */
		/* get node of second serial port */
		retval = fdt_path_offset(fdt, "/whitney/escc/ch-b");
		if(retval < 0) {
			bprint("fdt_path_offset failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: no /whitney/escc/ch-b node found!\n");
			return;
		}
		nodeoffset = retval;

		/* set connector property to modem */
		retval = fdt_setprop_string(fdt, nodeoffset, "AAPL,connector", "cobalt");
		if(retval < 0) {
			bprint("fdt_setprop_string failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: property AAPL,connector of node /whitney/escc/ch-b could not be changed!\n");
			return;
		}

#if 0
		/* 2300 doesn't have a media-bay */
		/* get media-bay node */
		retval = fdt_path_offset(fdt, "/whitney/media-bay");
		if(retval < 0) {
			bprint("fdt_path_offset failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: no /whitney/media-bay node found!\n");
			return;
		}
		nodeoffset = retval;

		/* delete media-bay node */
		retval = fdt_del_node(fdt, nodeoffset);
		if(retval < 0) {
			bprint("fdt_del_node failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: couldn't delete node /whitney/media-bay!\n");
			return;
		}
#endif
		
		/* 2300 doesn't have a keystone */
		/* get keystone node */
		retval = fdt_path_offset(fdt, "/whitney/keystone");
		if(retval < 0) {
			bprint("fdt_path_offset failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: no /whitney/keystone node found!\n");
			return;
		}
		nodeoffset = retval;

		/* delete keystone node */
		retval = fdt_del_node(fdt, nodeoffset);
		if(retval < 0) {
			bprint("fdt_del_node failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: couldn't delete node /whitney/keystone!\n");
			return;
		}
		
		break;

	case MACHID_POWERBOOK5300:
		break;

	case MACHID_POWERBOOK1400:
		/* 1400 doesn't have a (built-in) keystone */
		/* get keystone node */
		retval = fdt_path_offset(fdt, "/whitney/keystone");
		if(retval < 0) {
			bprint("fdt_path_offset failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: no /whitney/keystone node found!\n");
			return;
		}
		nodeoffset = retval;

		/* delete keystone node */
		retval = fdt_del_node(fdt, nodeoffset);
		if(retval < 0) {
			bprint("fdt_del_node failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_machdep: couldn't delete node /whitney/keystone!\n");
			return;
		}
		break;
	}
}

/*
 * populate the /chosen node with
 * ramdisk parameters and command line
 */
void setup_devtree_chosen(void *fdt, char *boot_display_path)
{
	int retval, nodeoffset;
	unsigned long setval;

	retval = fdt_path_offset(fdt, "/chosen");
	if(retval < 0) {
		bprint("fdt_path_offset failed (");
		drawhex(retval);
		bprint(")\n");
		bprint("setup_devtree_chosen: no /chosen node found!\n");
		return;
	}
	nodeoffset = retval;

	retval = fdt_setprop(fdt, nodeoffset, "linux,bootx",
			NULL, 0);
	if(retval < 0) {
		bprint("fdt_setprop failed (");
		drawhex(retval);
		bprint(")\n");
	}

	if(boot_display_path != NULL) {
		retval = fdt_setprop_string(fdt, nodeoffset, "linux,stdout-path",
				boot_display_path);
		if(retval < 0) {
			bprint("fdt_setprop_string failed (");
			drawhex(retval);
			bprint(")\n");
		}
	}

	if(boot_infos->ram_disk && boot_infos->ram_disk_size) {
		setval = boot_infos_loc +boot_infos->ram_disk;
		retval = fdt_setprop_cell(fdt, nodeoffset, "linux,initrd-start",
				setval);
		if(retval < 0) {
			bprint("fdt_setprop_cell failed (");
			drawhex(retval);
			bprint(")\n");
		}

		retval = fdt_add_mem_rsv(fdt, setval, boot_infos->ram_disk_size);
		if(retval < 0) {
			bprint("fdt_add_mem_rsv failed (");
			drawhex(retval);
			bprint(")\n");
		}
	
		setval += boot_infos->ram_disk_size;
		retval = fdt_setprop_cell(fdt, nodeoffset, "linux,initrd-end",
				setval);
		if(retval < 0) {
			bprint("fdt_setprop_cell failed (");
			drawhex(retval);
			bprint(")\n");
		}
	} else {
		fdt_delprop(fdt, nodeoffset, "linux,initrd-start");
		fdt_delprop(fdt, nodeoffset, "linux,initrd-end");
	}

	if(boot_infos->kernel_params_offset) {
		setval = (unsigned long)boot_infos + boot_infos->kernel_params_offset;
		retval = fdt_setprop_string(fdt, nodeoffset, "bootargs",
				(char *)setval);
		if(retval < 0) {
			bprint("fdt_setprop_string failed (");
			drawhex(retval);
			bprint(")\n");
		}
	} else {
		fdt_delprop(fdt, nodeoffset, "bootargs");
	}
}

/*
 * populate the display device's node with
 * the parameters from boot_infos
 */
void setup_devtree_display(void *fdt, char *boot_display_path)
{
	int retval, nodeoffset, len;
	unsigned long *retp;
	unsigned long setval;

	retval = fdt_node_offset_by_prop_value(fdt, -1, "device_type",
			"display", sizeof("display"));
	if(retval < 0) {
		bprint("fdt_node_offset_by_prop_value failed (");
		drawhex(retval);
		bprint(")\n");
		bprint("setup_devtree_display: no display device found!\n");
		return;
	}
	nodeoffset = retval;

	while (nodeoffset != -FDT_ERR_NOTFOUND) {
		retp = (unsigned long *)fdt_getprop(fdt, nodeoffset, "address", &len);
		if(retp == NULL) {
			bprint("fdt_getprop failed (");
			drawhex(len);
			bprint(")\n");
			bprint("setup_devtree_display: display device without address property found ... skipping!\n");
			goto skip;
		}
		if(*retp != (unsigned long)boot_infos->dispDeviceBase) {
			bprint("setup_devtree_display: currently inactive display device found ... skipping!\n");
			goto skip;
		}

		retval = fdt_get_path(fdt, nodeoffset, boot_display_path, 32);
		if(retval < 0) {
			bprint("fdt_get_path failed (");
			drawhex(retval);
			bprint(")\n");
			bprint("setup_devtree_display: couldn't determine full path of display device node ... skipping!\n");
			goto skip;
		}

		retval = fdt_setprop(fdt, nodeoffset, "linux,boot-display",
				NULL, 0);
		if(retval < 0) {
			bprint("fdt_setprop failed (");
			drawhex(retval);
			bprint(")\n");
		}

		retval = fdt_setprop(fdt, nodeoffset, "linux,opened",
				NULL, 0);
		if(retval < 0) {
			bprint("fdt_setprop failed (");
			drawhex(retval);
			bprint(")\n");
		}

		setval = (unsigned long)boot_infos->dispDeviceBase;
		retval = fdt_setprop_cell(fdt, nodeoffset, "linux,bootx-addr",
				setval);
		if(retval < 0) {
			bprint("fdt_setprop_cell failed (");
			drawhex(retval);
			bprint(")\n");
		}

		setval = boot_infos->dispDeviceDepth;
		retval = fdt_setprop_cell(fdt, nodeoffset, "linux,bootx-depth",
				setval);
		if(retval < 0) {
			bprint("fdt_setprop_cell failed (");
			drawhex(retval);
			bprint(")\n");
		}

		setval = boot_infos->dispDeviceRect[2] - boot_infos->dispDeviceRect[0];
		retval = fdt_setprop_cell(fdt, nodeoffset, "linux,bootx-width",
				setval);
		if(retval < 0) {
			bprint("fdt_setprop_cell failed (");
			drawhex(retval);
			bprint(")\n");
		}

		setval = boot_infos->dispDeviceRect[3] - boot_infos->dispDeviceRect[1];
		retval = fdt_setprop_cell(fdt, nodeoffset, "linux,bootx-height",
				setval);
		if(retval < 0) {
			bprint("fdt_setprop_cell failed (");
			drawhex(retval);
			bprint(")\n");
		}

		setval = boot_infos->dispDeviceRowBytes;
		retval = fdt_setprop_cell(fdt, nodeoffset, "linux,bootx-linebytes",
				setval);
		if(retval < 0) {
			bprint("fdt_setprop_cell failed (");
			drawhex(retval);
			bprint(")\n");
		}

skip:
		nodeoffset = fdt_node_offset_by_prop_value(fdt, nodeoffset,
				"device_type", "display", sizeof("display"));
	}
}

void setup_devtree(void *fdt)
{
	int retval;
	char boot_display_path[32] = "";

	/* check device tree header */
	retval = fdt_check_header(fdt);
	if(retval < 0) {
		bprint("fdt_check_header failed (");
		drawhex(retval);
		bprint(")\n");
		exit();
	}

	setup_devtree_machdep(fdt);

	setup_devtree_memory(fdt);

	setup_devtree_display(fdt, boot_display_path);

	bprint("setup_devtree: boot display node path:");
	if(boot_display_path[0] != '\0') {
		bprint(boot_display_path);
		bprint("\n");
	} else
		bprint("not found!\n");

	setup_devtree_chosen(fdt, boot_display_path);

	retval = fdt_totalsize(fdt);
	if (retval > boot_infos->device_tree_size) {
		bprint("setup_devtree: fdt too big for reserved space (");
		drawhex(boot_infos->device_tree_size);
		bprint(")\n");
		exit();
	}
	boot_infos->device_tree_size = retval;
}

void
setup_misc (void)
{
	unsigned long zimage_start, zimage_size, old_params_size;
	unsigned long kernel_size_precalc;

#ifdef LOADER_PRINT
	unsigned long i;

	clearscreen();

	g_loc_X = 0;
	g_loc_Y = 0;
	g_max_loc_X = boot_infos->dispDeviceRect[2] / 8;
	g_max_loc_Y = boot_infos->dispDeviceRect[3] / 16;

	bprint("Welcome to Linux Second-Stage Boot Loader\n\n");
	bprint("Display base = 0x");
	drawhex((unsigned long)boot_infos->dispDeviceBase);
	bprint("\n");
	flushscreen();

	/* do minimal setup for semi-correct cmap */
	switch ((unsigned long)boot_infos->dispDeviceBase & 0xfff00000UL) {
	case 0x100000UL:
		init_ariel2_cmap();
		break;
	case 0xe0100000UL:
		init_true_cmap(0xe0f30000UL, 16, 1);
		break;
	case 0x60000000UL:
		init_true_cmap(0x50f20040UL, 2, 0);
		break;
	default:
		if (boot_infos->architecture & BOOT_ARCH_NUBUS_PERFORMA)
			init_direct_cmap(0x50f24000, 4, 0);
		break;
	}

	print_mem_info();
	flushscreen();
#endif /* LOADER_PRINT */

	if (ramdisk_size) {
		bprint("RAM disk found at 0x");
		drawhex(ramdisk_base);
		bprint(", size = 0x");
		drawhex(ramdisk_size);
		bprint("\n");
	}

	/* mark program+data location unavailable */
	mem_pieces_remove(&phys_mem, TEXT_BASE, (unsigned long)&end - TEXT_BASE, 1);
	mem_pieces_remove(&phys_mem, ramdisk_base, ramdisk_size, 1);

	zimage_start = (unsigned long)&kernel_img_start;
	zimage_size = (unsigned long)&kernel_img_end - zimage_start;

	bprint("Compressed kernel found at 0x");
	drawhex(zimage_start);
	bprint(", size = 0x");
	drawhex(zimage_size);
	bprint("\n");

	kernel_size = KERNEL_END - KERNELBASE/* - LOAD_OFFSET*/;
	kernel_size_precalc = kernel_size
                        + boot_infos->total_params_size + ramdisk_size
                        + KERNEL_STACK_SIZE;
	kernel_src = (unsigned long) mem_pieces_find(kernel_size_precalc, 32);

	if (kernel_src == 0xffffffff) {
		bprint("Not enough space to decompress zImage\n");
		exit();
	}

	bprint("Decompressing kernel....");

	gunzip((void *) kernel_src, kernel_size,
	       (unsigned char *) zimage_start, (int *) &zimage_size);

	bprint("done\n");
	bprint("Unzipped size = 0x");
	drawhex(zimage_size);
	bprint("\n");

	bprint("kernel at 0x");
	drawhex(kernel_src);
	bprint(", size = 0x");
	drawhex(kernel_size);
	bprint("\n");

	kernel_size = PAGE_ALIGN(kernel_size);
	memset((void *)(kernel_src + kernel_size), 0, KERNEL_STACK_SIZE);
	kernel_stack = kernel_size + KERNEL_STACK_SIZE - 512 + LOAD_OFFSET;
	kernel_stack &= ~0x0f;
	kernel_size += KERNEL_STACK_SIZE;
	kernel_size = PAGE_ALIGN(kernel_size);
	boot_infos_loc = kernel_size + LOAD_OFFSET;

	old_params_size = boot_infos->total_params_size;

	if (boot_infos->architecture & BOOT_ARCH_NUBUS) {
		boot_infos->device_tree_offset = PAGE_ALIGN(boot_infos->total_params_size);
		boot_infos->device_tree_size = end_dtb - start_dtb;
	}
	boot_infos->total_params_size = boot_infos->device_tree_offset + PAGE_ALIGN(boot_infos->device_tree_size);

	if (ramdisk_size) {

		bprint("Relocating RAM disk....");

		boot_infos->ram_disk =
				PAGE_ALIGN(boot_infos->total_params_size);
		boot_infos->ram_disk_size = ramdisk_size;
		boot_infos->total_params_size = boot_infos->ram_disk +
						PAGE_ALIGN(boot_infos->ram_disk_size);
		memcpy((void *)(kernel_src +kernel_size +boot_infos->ram_disk),
		       (void *)ramdisk_base, ramdisk_size);

		bprint("done\n");
		bprint("Relocated to 0x");
		drawhex(kernel_size +boot_infos->ram_disk);
		bprint(" (size = 0x");
		drawhex(boot_infos->ram_disk_size);
		bprint(")\n");
		mem_pieces_append(&phys_mem, ramdisk_base, ramdisk_size);
		mem_pieces_sort(&phys_mem);
		mem_pieces_coalesce(&phys_mem);
	}

	if (boot_infos->architecture & BOOT_ARCH_NUBUS) {
		bprint("Source address of device tree blob: 0x");
		drawhex(start_dtb);
		bprint("\nDestination address for device tree blob: 0x");
		drawhex(kernel_size + boot_infos->device_tree_offset);
		bprint("\nSize of device tree blob: 0x");
		drawhex(boot_infos->device_tree_size);
	}

	bprint("\nCopying boot infos parameters....");

	memcpy((void *)(kernel_src + kernel_size), (void *)boot_infos,
	       old_params_size);

	bprint("done\n");

	if (boot_infos->architecture & BOOT_ARCH_NUBUS) {
		bprint("Copying device tree blob....");

		memcpy((void *)(kernel_src + kernel_size + boot_infos->device_tree_offset), (void *)start_dtb,
			boot_infos->device_tree_size);

		bprint("done\n");

		bprint("Configuring device tree ....");

		setup_devtree((void *)(kernel_src + kernel_size + boot_infos->device_tree_offset));

		bprint("done\n");

		bprint("Final size of device tree blob: 0x");
		drawhex(boot_infos->device_tree_size);
		bprint("\n");
	}

	kernel_size += boot_infos->total_params_size;

	mem_pieces_append(&phys_mem, (unsigned long)end_of_code, (unsigned long)&end - (unsigned long)end_of_code);
	mem_pieces_sort(&phys_mem);
	mem_pieces_coalesce(&phys_mem);
	/* kernel source */
	mem_pieces_remove(&phys_mem, kernel_src, kernel_size, 1);
	/* kernel destination */
	mem_pieces_remove(&phys_mem, LOAD_OFFSET, kernel_size, 1);

	code_size = (unsigned long) end_of_code - TEXT_BASE;
	code_reloc = (unsigned long) mem_pieces_find(code_size, 0x1000);
	code_restart = (unsigned long) _restart - TEXT_BASE + code_reloc;

//	if (code_reloc >= TEXT_BASE - PAGE_ALIGN(code_size)) {
//		bprint("Failed to find a suitable memory for relocation\n");
//		exit();
//	}

	bprint("Will enter kernel after relocating ourselves to 0x");
	drawhex(code_reloc);
	bprint(" (size = 0x");
	drawhex(code_size);
	bprint(")\nRestarting at 0x");
	drawhex(code_restart);

#ifdef LOADER_PRINT
	if (booter_debug_wait) {
		bprint("\n\n");
		bprint("Waiting a bit so that you can read all at the top");
		for (i = 0; i < 0x1000000 * booter_debug_wait; i++) {
			if (i % 0x1000000 == 1)
				bprint(".");
			eieio();
		}
	}
#endif
}


void *
zalloc(void *x, unsigned items, unsigned size)
{
	void *p;
	
	size *= items;
	size = (size + 7) & -8;
	p = (void *) mem_pieces_find(size, 8);
	if (p == (void *) 0xffffffff) {
		puts("oops... out of memory\n");
		exit();
	}
	return p;
}

void
zfree(void *x, void *addr, unsigned nb)
{
}

#define HEAD_CRC	2
#define EXTRA_FIELD	4
#define ORIG_NAME	8
#define COMMENT		0x10
#define RESERVED	0xe0

#define DEFLATED	8


static void
gunzip(void *dst, int dstlen, unsigned char *src, int *lenp)
{
	z_stream s = gzstate.s;
	int r, i, flags;
	
	/* skip header */
	i = 10;
	flags = src[3];
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
		puts("bad gzipped data\n");
		exit();
	}
	if ((flags & EXTRA_FIELD) != 0)
		i = 12 + src[10] + (src[11] << 8);
	if ((flags & ORIG_NAME) != 0)
		while (src[i++] != 0);
			;
	if ((flags & COMMENT) != 0)
		while (src[i++] != 0);
			;
	if ((flags & HEAD_CRC) != 0)
		i += 2;
	if (i >= *lenp) {
		puts("gunzip: ran out of data in header\n");
		exit();
	}
	
//	s.zalloc = zalloc;
//	s.zfree = zfree;
	s.workspace = gzstate.scratch;
	if (zlib_inflate_workspacesize() > sizeof(gzstate.scratch)) {
		puts("insufficient scratch space for gunzip\n\r");
		exit();
	}
	r = zlib_inflateInit2(&s, -MAX_WBITS);
	if (r != Z_OK) {
		puts("inflateInit2 failed with ");
		drawhex(r);
		exit();
	}
	s.next_in = src + i;
	s.avail_in = *lenp - i;
	s.next_out = dst;
	s.avail_out = dstlen;
	r = zlib_inflate(&s, Z_FINISH);
	if (r != Z_OK && r != Z_STREAM_END) {
		puts("inflate failed with ");
		drawhex(r);
		exit();
	}
	*lenp = s.next_out - (unsigned char *) dst;
	zlib_inflateEnd(&s);
}
#endif /* BOOTX_MEM_CHECK */

static char *
strstr(const char *s1, const char *s2)
{
	int l1, l2;

	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
		l1--;
		if (!memcmp(s1,s2,l2))
			return (char *) s1;
		s1++;
	}
	return NULL;
}

static unsigned long
strtoul(const char *cp, char **endp, unsigned int base)
{
	unsigned long result = 0,value;

	if (!base) {
		base = 10;
		if (*cp == '0') {
			base = 8;
			cp++;
			if ((*cp == 'x') && isxdigit(cp[1])) {
				cp++;
				base = 16;
			}
		}
	}
	while (isxdigit(*cp) &&
	       (value = isdigit(*cp) ? *cp-'0' : toupper(*cp)-'A'+10) < base) {
		result = result*base + value;
		cp++;
	}
	if (endp)
		*endp = (char *)cp;
	return result;
}

#if 0
static char * strncpy(char * dest,const char *src,size_t count)
{
	char *tmp = dest;

	while (count-- && (*dest++ = *src++) != '\0')
		/* nothing */;

	return tmp;
}
#endif

#ifdef LOADER_PRINT
#define delay(a) do { int i; for(i=0; i<a; i++); } while(0)

static void
init_ariel2_cmap(void)
{
	volatile unsigned char *cmap_adr = (volatile unsigned char *)
						0x50f24000UL;
	volatile unsigned char *cmap_data = cmap_adr + 1;
	volatile unsigned char *cmap_ctrl = cmap_adr + 2;
	int offset, cmap_shift, cmap_size;
	unsigned char val;

	val = *cmap_ctrl; eieio();
	switch (val - 8) {
	case 0:
		cmap_size = 2;
		cmap_shift = 7;
		break;
	case 1:
		cmap_size = 4;
		cmap_shift = 6;
		break;
	case 2:
		cmap_size = 16;
		cmap_shift = 4;
		break;
	case 3:
		cmap_size = 16;
		cmap_shift = 0;
		break;
	case 4:
		cmap_size = 32;
		cmap_shift = 0;
		break;
	default:
		return;
	}

	offset = (1 << cmap_shift) - 1;
	*cmap_adr = offset; eieio();
	delay(0x1000);
	*cmap_data = 0; eieio();
	*cmap_data = 0; eieio();
	*cmap_data = 0; eieio();
	delay(0x1000);
	*cmap_adr = ((cmap_size - 1) << cmap_shift) + offset; eieio();
	delay(0x1000);
	*cmap_data = 0xff; eieio();
	*cmap_data = 0xff; eieio();
	*cmap_data = 0xff; eieio();
}

static void
init_true_cmap(unsigned long addr, int off, int trans)
{
	volatile unsigned char *cmap_adr = (volatile unsigned char *)addr;
	volatile unsigned char *cmap_data;
	unsigned long cmap_shift, cmap_size, offset;

	cmap_data = cmap_adr + off;
	switch (boot_infos->dispDeviceDepth) {
	case 1:
		cmap_size = 2;
		cmap_shift = 7;
		break;
	case 2:
		cmap_size = 4;
		cmap_shift = 6;
		break;
	case 4:
		cmap_size = 16;
		cmap_shift = 4;
		break;
	case 8:
		cmap_size = 16;
		cmap_shift = 0;
		break;
	case 16:
		cmap_size = 32;
		cmap_shift = 0;
		break;
	case 32:
		cmap_size = 256;
		cmap_shift = 0;
		break;
	default:
		return;
	}

	offset = (1 << cmap_shift) - 1;
	*cmap_adr = offset; eieio();
	delay(0x1000);
	*cmap_data = 0; eieio();
	*cmap_data = 0; eieio();
	*cmap_data = 0; eieio();
	if (trans) {
		*cmap_data = 0; eieio();
	}
	delay(0x1000);
	*cmap_adr = ((cmap_size - 1) << cmap_shift) + offset; eieio();
	delay(0x1000);
	*cmap_data = 0xff; eieio();
	*cmap_data = 0xff; eieio();
	*cmap_data = 0xff; eieio();
	if (trans) {
		*cmap_data = 0; eieio();
	}
}

static void
init_direct_cmap(unsigned long addr, int off, int trans)
{
	volatile unsigned char *cmap_adr = (volatile unsigned char *)addr;
	volatile unsigned char *cmap_data;
	unsigned long cmap_shift, cmap_size, offset;

	cmap_data = cmap_adr + off;
	switch (boot_infos->dispDeviceDepth) {
	case 1:
		cmap_size = 2;
		cmap_shift = 7;
		break;
	case 2:
		cmap_size = 4;
		cmap_shift = 6;
		break;
	case 4:
		cmap_size = 16;
		cmap_shift = 4;
		break;
	case 8:
		cmap_size = 256;
		cmap_shift = 0;
		break;
	case 16:
		cmap_size = 32;
		cmap_shift = 0;
		break;
	case 32:
		cmap_size = 256;
		cmap_shift = 0;
		break;
	default:
		return;
	}

	offset = (1 << cmap_shift) - 1;
	*cmap_adr = offset; eieio();
	delay(0x1000);
	*cmap_data = 0; eieio();
	*cmap_data = 0; eieio();
	*cmap_data = 0; eieio();
	if (trans) {
		*cmap_data = 0; eieio();
	}
	delay(0x1000);
	*cmap_adr = ((cmap_size - 1) << cmap_shift) + offset; eieio();
	delay(0x1000);
	*cmap_data = 0xff; eieio();
	*cmap_data = 0xff; eieio();
	*cmap_data = 0xff; eieio();
	if (trans) {
		*cmap_data = 0; eieio();
	}
}

static unsigned char *
calc_base(struct boot_infos *bi, int x, int y)
{
	unsigned char *base;

	base = bi->logicalDisplayBase;
	if (base == 0)
		base = bi->dispDeviceBase;
	base += ((x + bi->dispDeviceRect[0])*bi->dispDeviceDepth) >> 3;
	base += (y + bi->dispDeviceRect[1]) * bi->dispDeviceRowBytes;
	return base;
}


static inline void dcbst(const void* addr)
{
	unsigned long pvr;

	/*
	 * Apple AV card in PDS slot causes unrecoverable hang on PPC601
	 * if r0 holds AV card's physical address range at unknown time
	 */
	asm volatile ("mfspr %0, 287" : "=r" (pvr));
	if ((pvr >> 16) != 1)
		asm volatile ("dcbst 0,%0" :: "r" (addr));
}


void
clearscreen(void)
{
	struct boot_infos* bi	= boot_infos;
	unsigned long *base	= (unsigned long *) calc_base(bi, 0, 0);
	unsigned long width 	= ((bi->dispDeviceRect[2] - bi->dispDeviceRect[0]) *
					bi->dispDeviceDepth) >> 5;
	int i,j;

	for (i=0; i<(bi->dispDeviceRect[3] - bi->dispDeviceRect[1]); i++)
	{
		unsigned long *ptr = base;
		for(j=width; j; --j)
			*(ptr++) = 0;
		base += bi->dispDeviceRowBytes >> 2;
	}
}


static void
flushscreen(void)
{
	struct boot_infos* bi	= boot_infos;
	unsigned long *base	= (unsigned long *) calc_base(bi, 0, 0);
	unsigned long width 	= ((bi->dispDeviceRect[2] - bi->dispDeviceRect[0]) *
					bi->dispDeviceDepth) >> 5;
	int i,j;
	
	for (i=0; i<(bi->dispDeviceRect[3] - bi->dispDeviceRect[1]); i++)
	{
		unsigned long *ptr = base;
		for(j=width; j>0; j-=8) {
			dcbst(ptr);
			ptr += 8;
		}
		base += (bi->dispDeviceRowBytes >> 2);
	}
}


static void
drawchar(char c)
{
	int cline = 0, x;

	switch (c) {
	case '\b':
		if (g_loc_X > 0)
			--g_loc_X;
		break;
	case '\t':
		g_loc_X = (g_loc_X & -8) + 8;
		break;
	case '\r':
		g_loc_X = 0;
		break;
	case '\n':
		g_loc_X = 0;
		g_loc_Y++;
		cline = 1;
		break;
	default:
		draw_byte(c, g_loc_X++, g_loc_Y);
	}
	if (g_loc_X >= g_max_loc_X) {
		g_loc_X = 0;
		g_loc_Y++;
		cline = 1;
	}
	if (g_loc_Y >= g_max_loc_Y)
		g_loc_Y = 0;
	if (cline) {
		for (x = 0; x < g_max_loc_X; ++x)
			draw_byte(' ', x, g_loc_Y);
	}
}

void
drawstring(const char *c)
{
	while (*c)
		drawchar(*c++);
}

void
drawhex(unsigned long v)
{
	static char hex_table[] = "0123456789abcdef";
	
	drawchar(hex_table[(v >> 28) & 0x0000000FUL]);
	drawchar(hex_table[(v >> 24) & 0x0000000FUL]);
	drawchar(hex_table[(v >> 20) & 0x0000000FUL]);
	drawchar(hex_table[(v >> 16) & 0x0000000FUL]);
	drawchar(hex_table[(v >> 12) & 0x0000000FUL]);
	drawchar(hex_table[(v >>  8) & 0x0000000FUL]);
	drawchar(hex_table[(v >>  4) & 0x0000000FUL]);
	drawchar(hex_table[(v >>  0) & 0x0000000FUL]);
}


static void
draw_byte(unsigned char c, long locX, long locY)
{
	struct boot_infos* bi	= boot_infos;
	unsigned char *base	= calc_base(bi, locX << 3, locY << 4);
	unsigned char *font	= &vga_font[((unsigned long)c) * 16];

	if (bi->dispDeviceDepth == 32)
                draw_byte_32(font, (unsigned long *)base);
	else if (bi->dispDeviceDepth == 16)
                draw_byte_16(font, (unsigned long *)base);
	else if (bi->dispDeviceDepth == 8)
                draw_byte_8(font, (unsigned long *)base);
	else if (bi->dispDeviceDepth == 4)
                draw_byte_4(font, (unsigned long *)base); 
	else if (bi->dispDeviceDepth == 2)
                draw_byte_2(font, (unsigned short *)base);
	else if (bi->dispDeviceDepth == 1)
                draw_byte_1(font, (unsigned char *)base);
}

static unsigned long expand_bits_8[16] = {
	0x00000000,
	0x000000ff,
	0x0000ff00,
	0x0000ffff,
	0x00ff0000,
	0x00ff00ff,
	0x00ffff00,
	0x00ffffff,
	0xff000000,
	0xff0000ff,
	0xff00ff00,
	0xff00ffff,
	0xffff0000,
	0xffff00ff,
	0xffffff00,
	0xffffffff
};

static unsigned long expand_bits_16[4] = {
	0x00000000,
	0x0000ffff,
	0xffff0000,
	0xffffffff
};


static void
draw_byte_32(unsigned char *font, unsigned long *base)
{
	struct boot_infos* bi		= boot_infos;
	int l, bits;	
	int fg = 0xFFFFFFFFUL;
	int bg = 0x00000000UL;
	

	for (l = 0; l < 16; ++l)
	{
		bits = *font++;
		base[0] = (-(bits >> 7) & fg) ^ bg;
		base[1] = (-((bits >> 6) & 1) & fg) ^ bg;
		base[2] = (-((bits >> 5) & 1) & fg) ^ bg;
		base[3] = (-((bits >> 4) & 1) & fg) ^ bg;
		base[4] = (-((bits >> 3) & 1) & fg) ^ bg;
		base[5] = (-((bits >> 2) & 1) & fg) ^ bg;
		base[6] = (-((bits >> 1) & 1) & fg) ^ bg;
		base[7] = (-(bits & 1) & fg) ^ bg;
		base = (unsigned long *) ((char *)base + bi->dispDeviceRowBytes);
	}
}

static void
draw_byte_16(unsigned char *font, unsigned long *base)
{
	struct boot_infos* bi		= boot_infos;
	int l, bits;	
	int fg = 0xFFFFFFFFUL;
	int bg = 0x00000000UL;
	unsigned long *eb = expand_bits_16;

	for (l = 0; l < 16; ++l)
	{
		bits = *font++;
		base[0] = (eb[bits >> 6] & fg) ^ bg;
		base[1] = (eb[(bits >> 4) & 3] & fg) ^ bg;
		base[2] = (eb[(bits >> 2) & 3] & fg) ^ bg;
		base[3] = (eb[bits & 3] & fg) ^ bg;
		base = (unsigned long *) ((char *)base + bi->dispDeviceRowBytes);
	}
}

static void
draw_byte_8(unsigned char *font, unsigned long *base)
{
	struct boot_infos* bi		= boot_infos;
	int l, bits;	
	int fg = 0x0F0F0F0FUL;
	int bg = 0x00000000UL;
	unsigned long *eb = expand_bits_8;

	for (l = 0; l < 16; ++l)
	{
		bits = *font++;
		base[0] = (eb[bits >> 4] & fg) ^ bg;
		base[1] = (eb[bits & 0xf] & fg) ^ bg;
		base = (unsigned long *) ((char *)base + bi->dispDeviceRowBytes);
	}
}

static unsigned long
find_expand_bits(unsigned char bits, int bpp, unsigned long mask)
{
	int i;
	unsigned long ret = 0;

	for (i = 0; i < (32 / bpp); i++) {
		if (bits & (1 << i)) {
			ret |= mask << (i * bpp);
		}
	}

	return ret;
}

static void
draw_byte_4(unsigned char *font, unsigned long *base)
{
	struct boot_infos* bi		= boot_infos;
	int l, bits;	
	int fg = 0xffffffffUL;
	int bg = 0x00000000UL;

	for (l = 0; l < 16; ++l)
	{
		unsigned long eb;
		bits = *font++;
		eb = find_expand_bits(bits, 4, 0xf);
		base[0] = (eb & fg) ^ bg;
		base = (unsigned long *) ((char *)base + bi->dispDeviceRowBytes);
	}
}

static void
draw_byte_2(unsigned char *font, unsigned short *base)
{
	struct boot_infos* bi		= boot_infos;
	int l;
	unsigned short bits;
	unsigned short fg = 0xffff;
	unsigned short bg = 0;

	for (l = 0; l < 16; ++l)
	{
		unsigned short eb;
		bits = *font++;
		eb = (unsigned short)find_expand_bits(bits, 2, 0x3);
		base[0] = (eb & fg) ^ bg;
		base = (unsigned short *)((char *)base+bi->dispDeviceRowBytes);
	}
}

static void
draw_byte_1(unsigned char *font, unsigned char *base)
{
	struct boot_infos* bi		= boot_infos;
	int l;
	unsigned char bits;
	unsigned char fg = 0xff;
	unsigned char bg = 0;

	for (l = 0; l <16; ++l)
	{
		bits = *font++;
		base[0] = (bits & fg) ^ bg;
		base = (unsigned char *) (base + bi->dispDeviceRowBytes);
	}
}

static unsigned char vga_font[cmapsz] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x81, 0xa5, 0x81, 0x81, 0xbd, 
0x99, 0x81, 0x81, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0xff, 
0xdb, 0xff, 0xff, 0xc3, 0xe7, 0xff, 0xff, 0x7e, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x6c, 0xfe, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x7c, 0xfe, 
0x7c, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 
0x3c, 0x3c, 0xe7, 0xe7, 0xe7, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x7e, 0x18, 0x18, 0x3c, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3c, 
0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x99, 0xbd, 
0xbd, 0x99, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x1e, 0x0e, 
0x1a, 0x32, 0x78, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18, 0x18, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x33, 0x3f, 0x30, 0x30, 0x30, 
0x30, 0x70, 0xf0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x63, 
0x7f, 0x63, 0x63, 0x63, 0x63, 0x67, 0xe7, 0xe6, 0xc0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x18, 0x18, 0xdb, 0x3c, 0xe7, 0x3c, 0xdb, 0x18, 0x18, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfe, 0xf8, 
0xf0, 0xe0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0e, 
0x1e, 0x3e, 0xfe, 0x3e, 0x1e, 0x0e, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 
0x66, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xdb, 
0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x7c, 0xc6, 0x60, 0x38, 0x6c, 0xc6, 0xc6, 0x6c, 0x38, 0x0c, 0xc6, 
0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xfe, 0xfe, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3c, 
0x7e, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x7e, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x7e, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 
0xc0, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x7c, 0x7c, 0xfe, 0xfe, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0x7c, 0x7c, 
0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x18, 0x3c, 0x3c, 0x3c, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6c, 
0x6c, 0xfe, 0x6c, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 
0x18, 0x18, 0x7c, 0xc6, 0xc2, 0xc0, 0x7c, 0x06, 0x06, 0x86, 0xc6, 0x7c, 
0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc2, 0xc6, 0x0c, 0x18, 
0x30, 0x60, 0xc6, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x6c, 
0x6c, 0x38, 0x76, 0xdc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 
0x30, 0x30, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x18, 
0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 
0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0xc6, 0xc6, 0x7c, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 
0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0xc6, 0xfe, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x7c, 0xc6, 0x06, 0x06, 0x3c, 0x06, 0x06, 0x06, 0xc6, 0x7c, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 
0x0c, 0x0c, 0x0c, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xc0, 
0xc0, 0xc0, 0xfc, 0x06, 0x06, 0x06, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x38, 0x60, 0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xc6, 0x06, 0x06, 0x0c, 0x18, 
0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 
0xc6, 0xc6, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x06, 0x06, 0x0c, 0x78, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 
0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0c, 0x06, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 
0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
0x30, 0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x7c, 0xc6, 0xc6, 0x0c, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xde, 0xde, 
0xde, 0xdc, 0xc0, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 
0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x66, 0x66, 0xfc, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xc0, 
0xc0, 0xc2, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x6c, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x62, 0x66, 0xfe, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 
0x60, 0x60, 0x60, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 
0xc2, 0xc0, 0xc0, 0xde, 0xc6, 0xc6, 0x66, 0x3a, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x0c, 
0x0c, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0xcc, 0x78, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xe6, 0x66, 0x66, 0x6c, 0x78, 0x78, 0x6c, 0x66, 0x66, 0xe6, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x60, 0x60, 0x60, 0x60, 0x60, 
0x60, 0x62, 0x66, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xe7, 
0xff, 0xff, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xc6, 0xe6, 0xf6, 0xfe, 0xde, 0xce, 0xc6, 0xc6, 0xc6, 0xc6, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 
0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x66, 
0x66, 0x66, 0x7c, 0x60, 0x60, 0x60, 0x60, 0xf0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xd6, 0xde, 0x7c, 
0x0c, 0x0e, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x6c, 
0x66, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 
0xc6, 0x60, 0x38, 0x0c, 0x06, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xff, 0xdb, 0x99, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 
0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xc3, 
0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xdb, 0xff, 0x66, 0x66, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xc3, 0x66, 0x3c, 0x18, 0x18, 
0x3c, 0x66, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xc3, 
0xc3, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xff, 0xc3, 0x86, 0x0c, 0x18, 0x30, 0x60, 0xc1, 0xc3, 0xff, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 
0x30, 0x30, 0x30, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 
0xc0, 0xe0, 0x70, 0x38, 0x1c, 0x0e, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 
0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 
0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0c, 0x7c, 
0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x60, 
0x60, 0x78, 0x6c, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0xc0, 0xc6, 0x7c, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x0c, 0x3c, 0x6c, 0xcc, 
0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x38, 0x6c, 0x64, 0x60, 0xf0, 0x60, 0x60, 0x60, 0x60, 0xf0, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xcc, 0xcc, 
0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xcc, 0x78, 0x00, 0x00, 0x00, 0xe0, 0x60, 
0x60, 0x6c, 0x76, 0x66, 0x66, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x06, 0x00, 0x0e, 0x06, 0x06, 
0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00, 0xe0, 0x60, 
0x60, 0x66, 0x6c, 0x78, 0x78, 0x6c, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0xff, 0xdb, 
0xdb, 0xdb, 0xdb, 0xdb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 
0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x76, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0x0c, 0x1e, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0x60, 0x60, 0xf0, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0x60, 
0x38, 0x0c, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x30, 
0x30, 0xfc, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0xc3, 0xc3, 
0xc3, 0x66, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0xc3, 0xc3, 0xc3, 0xdb, 0xdb, 0xff, 0x66, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0xc3, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 
0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x0c, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0xfe, 0xcc, 0x18, 0x30, 0x60, 0xc6, 0xfe, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x0e, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0e, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x18, 
0x18, 0x18, 0x0e, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 
0xc6, 0xc6, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 
0xc2, 0xc0, 0xc0, 0xc0, 0xc2, 0x66, 0x3c, 0x0c, 0x06, 0x7c, 0x00, 0x00, 
0x00, 0x00, 0xcc, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x30, 0x00, 0x7c, 0xc6, 0xfe, 
0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6c, 
0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xcc, 0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x00, 0x78, 0x0c, 0x7c, 
0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x6c, 0x38, 
0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x60, 0x60, 0x66, 0x3c, 0x0c, 0x06, 
0x3c, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6c, 0x00, 0x7c, 0xc6, 0xfe, 
0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x00, 
0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x60, 0x30, 0x18, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc0, 0xc6, 0x7c, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x38, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3c, 0x66, 
0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x60, 0x30, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 
0xfe, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x38, 0x6c, 0x38, 0x00, 
0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00, 
0x18, 0x30, 0x60, 0x00, 0xfe, 0x66, 0x60, 0x7c, 0x60, 0x60, 0x66, 0xfe, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x3b, 0x1b, 
0x7e, 0xd8, 0xdc, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x6c, 
0xcc, 0xcc, 0xfe, 0xcc, 0xcc, 0xcc, 0xcc, 0xce, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x10, 0x38, 0x6c, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 
0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 
0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x30, 0x78, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x00, 0xcc, 0xcc, 0xcc, 
0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x00, 
0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x0c, 0x78, 0x00, 
0x00, 0xc6, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 
0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 
0xc3, 0xc0, 0xc0, 0xc0, 0xc3, 0x7e, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x38, 0x6c, 0x64, 0x60, 0xf0, 0x60, 0x60, 0x60, 0x60, 0xe6, 0xfc, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0xff, 0x18, 
0xff, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x66, 0x66, 
0x7c, 0x62, 0x66, 0x6f, 0x66, 0x66, 0x66, 0xf3, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x0e, 0x1b, 0x18, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 
0xd8, 0x70, 0x00, 0x00, 0x00, 0x18, 0x30, 0x60, 0x00, 0x78, 0x0c, 0x7c, 
0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x30, 
0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x18, 0x30, 0x60, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x60, 0x00, 0xcc, 0xcc, 0xcc, 
0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 
0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 
0x76, 0xdc, 0x00, 0xc6, 0xe6, 0xf6, 0xfe, 0xde, 0xce, 0xc6, 0xc6, 0xc6, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x6c, 0x6c, 0x3e, 0x00, 0x7e, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x6c, 0x6c, 
0x38, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60, 0xc0, 0xc6, 0xc6, 0x7c, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xc0, 
0xc0, 0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xfe, 0x06, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0xc0, 0xc0, 0xc2, 0xc6, 0xcc, 0x18, 0x30, 0x60, 0xce, 0x9b, 0x06, 
0x0c, 0x1f, 0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc2, 0xc6, 0xcc, 0x18, 0x30, 
0x66, 0xce, 0x96, 0x3e, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 
0x00, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x6c, 0xd8, 0x6c, 0x36, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd8, 0x6c, 0x36, 
0x6c, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x44, 0x11, 0x44, 
0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 
0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 
0x55, 0xaa, 0x55, 0xaa, 0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77, 
0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0xf8, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x36, 0x36, 0x36, 0x36, 
0x36, 0x36, 0x36, 0xf6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x36, 0x36, 0x36, 0x36, 
0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0xf8, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x36, 0x36, 0x36, 0x36, 
0x36, 0xf6, 0x06, 0xf6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x06, 0xf6, 
0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
0x36, 0xf6, 0x06, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xfe, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0xf8, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 
0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
0x36, 0x37, 0x30, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x30, 0x37, 0x36, 0x36, 0x36, 0x36, 
0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xf7, 0x00, 0xff, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0xff, 0x00, 0xf7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36, 0x36, 
0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 
0x36, 0xf7, 0x00, 0xf7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xff, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0xff, 0x00, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x36, 0x36, 0x36, 0x36, 
0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3f, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x1f, 0x18, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 
0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
0x36, 0x36, 0x36, 0xff, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0xff, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xf0, 0xf0, 0xf0, 
0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 
0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 
0x0f, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x76, 0xdc, 0xd8, 0xd8, 0xd8, 0xdc, 0x76, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0xd8, 0xcc, 0xc6, 0xc6, 0xc6, 0xcc, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xc6, 0xc6, 0xc0, 0xc0, 0xc0, 
0xc0, 0xc0, 0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0xfe, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0xfe, 0xc6, 0x60, 0x30, 0x18, 0x30, 0x60, 0xc6, 0xfe, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0xd8, 0xd8, 
0xd8, 0xd8, 0xd8, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x66, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x18, 0x3c, 0x66, 0x66, 
0x66, 0x3c, 0x18, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 
0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0x6c, 0x38, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x6c, 0x6c, 0x6c, 0xee, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x30, 0x18, 0x0c, 0x3e, 0x66, 
0x66, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x7e, 0xdb, 0xdb, 0xdb, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x03, 0x06, 0x7e, 0xdb, 0xdb, 0xf3, 0x7e, 0x60, 0xc0, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x30, 0x60, 0x60, 0x7c, 0x60, 
0x60, 0x60, 0x30, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 
0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 
0x18, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x0c, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0c, 0x00, 0x7e, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x1b, 0x1b, 0x1b, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
0x18, 0x18, 0x18, 0x18, 0xd8, 0xd8, 0xd8, 0x70, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x7e, 0x00, 0x18, 0x18, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 0x00, 
0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x6c, 0x6c, 
0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0c, 0x0c, 
0x0c, 0x0c, 0x0c, 0xec, 0x6c, 0x6c, 0x3c, 0x1c, 0x00, 0x00, 0x00, 0x00, 
0x00, 0xd8, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xd8, 0x30, 0x60, 0xc8, 0xf8, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 
};
#endif /* LOADER_PRINT */
